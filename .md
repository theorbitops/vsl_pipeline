# Arquitetura Completa do Pipeline de Processamento de VSLs

## 1. Visão Geral

Este documento descreve em detalhes toda a arquitetura projetada para o
sistema de ingestão, download, transcrição, categorização futura e
armazenamento de vídeos VSL provenientes de URLs m3u8 ou páginas de
vendas.\
A arquitetura foi construída de forma **modular, resiliente, escalável**
e com foco em **tolerância a falhas**, usando:

-   FastAPI\
-   PostgreSQL\
-   Celery + Redis\
-   ffmpeg\
-   Whisper API\
-   Elasticsearch (futuro)

## 2. Componentes Principais

-   **FastAPI** -- Interface HTTP e orquestração manual do pipeline.
-   **PostgreSQL** -- Backend relacional para status, vídeos,
    transcrições e auditoria.
-   **Redis** -- Message broker para Celery.
-   **Celery Workers** -- Execução assíncrona das etapas do pipeline.
-   **ffmpeg** -- Download de vídeos e extração de áudio.
-   **Whisper API** -- Transcrição automatizada.
-   **Filesystem Local (/storage)** -- Armazenamento MVP de vídeos e
    áudios.

## 3. Fluxo Completo do Pipeline

1.  Uma URL é criada no banco (`status = pending_ingest`).

2.  A API chama: `POST /pipeline/start/{url_id}`

3.  O pipeline executa:

        download_video(url_id)
             ↓
        transcribe_video(video_id)
             ↓
        (futuro) categorize_transcript(transcript_id)

4.  O banco de dados é atualizado a cada etapa.

5.  Os vídeos e transcrições ficam armazenados permanentemente.

## 4. Banco de Dados

### Tabelas implementadas

-   `urls` -- controla status e metadados da URL.
-   `videos` -- caminho do vídeo armazenado e metadados técnicos.
-   `transcripts` -- texto completo + engine.
-   `jobs` -- log estruturado de todos os passos do pipeline.
-   `dead_letters` -- fila de mensagens com falhas.

Cada operação do pipeline cria um `Job` e, se falhar, um `DeadLetter`.

## 5. Baixar Vídeo com ffmpeg

A task `download_video` faz:

-   checa se já existe vídeo (`idempotência`)

-   baixa via:

        ffmpeg -i https://URL/main.m3u8 -c copy output.mp4

-   calcula tamanho e duração via `ffprobe`

-   salva o vídeo em `/storage/videos`

-   cria registro em `videos`

-   atualiza `urls.status = downloaded`

## 6. Transcrição com Whisper

A task `transcribe_video`:

-   checa se já existe transcript pronta (`idempotência`)

-   extrai áudio via ffmpeg para MP3 comprimido

-   envia para Whisper:

        POST https://api.openai.com/v1/audio/transcriptions

-   salva texto completo em `transcripts`

-   atualiza `urls.status = transcribed`

## 7. Orquestrador

`pipeline_orchestrator.start_url_pipeline(url_id)`:

-   carrega a URL

-   monta o pipeline:

        download_video.s(url_id) | transcribe_video.s()

-   dispara e retorna o ID da última task

## 8. Tolerância a Falhas

-   Tentativas futuras de retry podem ser habilitadas
-   Tasks são idempotentes
-   DLQ registra tudo que falhou
-   Jobs documentam todo o histórico de execução
-   Pipeline pode ser retomado a qualquer momento

## 9. Próximos passos

-   Implementar categorização inteligente
-   Indexar transcrições no Elasticsearch
-   Criar frontend do Swipe
-   Migrar para servidor dedicado de alta performance
